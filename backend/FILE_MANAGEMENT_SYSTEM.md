# Система управления файлами с версионированием

## Обзор

Улучшенная система управления бинарными файлами для медицинского проекта с поддержкой версионирования, организации по пациентам и медицинским типам файлов.

## Архитектура

### Гибридный подход хранения

- **Метаданные в SQLite**: Вся информация о файлах, версиях, связях
- **Файлы в файловой системе**: Сами бинарные данные организованы по пациентам

### Структура файловой системы

```
storage/
├── patients/
│   ├── patient_001/
│   │   ├── photos/
│   │   ├── ct_scans/
│   │   ├── stl_models/
│   │   └── documents/
│   └── patient_002/
└── temp/
```

## Типы медицинских файлов

### Поддерживаемые форматы

```python
MedicalFileType = {
    # Медицинские изображения
    "photo": "Клинические фотографии",
    "xray": "Рентгенограммы", 
    "panoramic": "Панорамные снимки",
    
    # КТ и МРТ данные
    "ct_scan": "Компьютерная томография",
    "dicom": "DICOM файлы",
    "mri": "Магнитно-резонансная томография",
    
    # 3D модели
    "stl_model": "STL модели для 3D печати",
    "obj_model": "OBJ 3D модели",
    "ply_model": "PLY 3D модели",
    
    # Документы
    "pdf": "PDF документы",
    "document": "Word, текстовые файлы",
    "report": "Медицинские отчеты"
}
```

### Типы версий файлов

```python
FileVersionType = {
    "baseline": "Исходная версия",
    "followup": "Контрольная версия",
    "treatment": "Связанная с лечением", 
    "surgical": "Хирургическая версия",
    "final": "Финальная версия"
}
```

## База данных

### Основные таблицы

#### Таблица `files`
- `id`: Уникальный идентификатор файла
- `patient_id`: Связь с пациентом
- `file_path`: Путь к файлу в файловой системе
- `file_type`: Тип медицинского файла
- `medical_category`: Категория (clinical, diagnostic, treatment, surgical)
- `study_date`: Дата исследования/съемки
- `body_part`: Область тела
- `file_size`: Размер файла в байтах
- `file_hash`: SHA256 хеш для контроля целостности
- `mime_type`: MIME-тип файла

#### Таблица `file_versions`
- `id`: Уникальный идентификатор версии
- `file_id`: Связь с основным файлом
- `version_number`: Номер версии
- `version_type`: Тип версии (baseline, followup, treatment, surgical, final)
- `version_description`: Описание изменений
- `created_by`: Пользователь, создавший версию
- `file_hash`: Хеш версии файла

## API Endpoints

### Загрузка файлов

#### `POST /api/v1/files/upload`
Загружает файл с автоматической организацией по пациенту и типу.

**Параметры формы:**
- `file`: Файл для загрузки
- `patient_id`: ID пациента
- `file_type`: Тип файла (photo, ct_scan, stl_model, и т.д.)
- `medical_category`: Категория (опционально)
- `study_date`: Дата исследования в формате YYYY-MM-DD (опционально)
- `body_part`: Область тела (опционально)
- `description`: Описание файла (опционально)

**Пример использования:**
```bash
curl -X POST "http://localhost:8000/api/v1/files/upload" \
  -H "Authorization: Bearer <token>" \
  -F "file=@ct_scan.dcm" \
  -F "patient_id=1" \
  -F "file_type=ct_scan" \
  -F "medical_category=diagnostic" \
  -F "study_date=2024-01-15" \
  -F "body_part=upper_jaw"
```

### Версионирование файлов

#### `POST /api/v1/files/upload-version/{file_id}`
Загружает новую версию существующего файла.

**Параметры:**
- `file_id`: ID существующего файла
- `version_type`: Тип версии (followup, treatment, surgical, final)
- `version_description`: Описание изменений

#### `GET /api/v1/files/{id}/versions`
Получает все версии файла.

### Получение файлов пациента

#### `GET /api/v1/files/patient/{patient_id}/files`
Получает все файлы пациента с фильтрацией.

**Параметры запроса:**
- `file_type`: Фильтр по типу файла
- `medical_category`: Фильтр по категории

#### `GET /api/v1/files/patient/{patient_id}/files/categorized`
Получает файлы пациента, сгруппированные по типам.

### Управление хранилищем

#### `GET /api/v1/files/patient/{patient_id}/storage-info`
Возвращает информацию о хранилище пациента:
- Общий размер файлов
- Количество файлов по типам
- Статистика использования

#### `POST /api/v1/files/patient/{patient_id}/cleanup`
Очищает временные файлы старше указанного возраста.

## Файловая организация

### Генерация путей файлов

Файлы автоматически организуются по следующему шаблону:
```
storage/patients/patient_{id}/{type}/{date}_{type_prefix}_{uuid}{extension}
```

**Примеры:**
- `storage/patients/patient_1/photos/20240115_photo_a1b2c3d4.jpg`
- `storage/patients/patient_1/ct_scans/20240120_ct_f5g6h7i8.dcm`
- `storage/patients/patient_1/stl_models/20240125_stl_j9k0l1m2.stl`

### Именование файлов

Формат имени файла: `{дата}_{префикс_типа}_{uuid}{расширение}`

**Префиксы типов:**
- photo → photo
- xray → xray
- ct_scan → ct
- dicom → dicom
- mri → mri
- stl_model → stl
- и т.д.

## Контроль целостности

### SHA256 хеширование
- Каждый файл имеет SHA256 хеш
- Хеши сохраняются в БД и могут использоваться для проверки целостности
- Хеши версий отслеживают изменения файлов

### Размеры файлов
- Автоматическое отслеживание размеров файлов
- Статистика использования хранилища

## Преимущества системы

### 1. Производительность
- Быстрые запросы к метаданным в SQLite
- Эффективное хранение больших бинарных файлов
- Индексирование по пациентам и типам

### 2. Масштабируемость
- Горизонтальное масштабирование файлового хранилища
- Разделение метаданных и содержимого
- Поддержка больших файлов (КТ, МРТ, 3D модели)

### 3. Безопасность
- Контроль целостности через хеширование
- Версионирование для отката изменений
- Аудит через отслеживание пользователей

### 4. Медицинская специфика
- Поддержка медицинских форматов (DICOM, STL)
- Категоризация по медицинскому назначению
- Отслеживание дат исследований

### 5. Управляемость
- Автоматическая организация файлов
- Очистка временных файлов
- Статистика использования

## Использование

### Инициализация сервиса

```python
from app.services.file_storage_service import FileStorageService

# Создание экземпляра с кастомным путем
storage = FileStorageService(base_storage_path="/custom/storage/path")

# Создание директорий пациента
storage.create_patient_directories(patient_id=123)

# Получение информации о хранилище
info = storage.get_patient_storage_info(patient_id=123)
print(f"Всего файлов: {info['file_count']}")
print(f"Общий размер: {info['total_size_mb']} MB")
```

### Создание файлов в коде

```python
from app.models.file import MedicalFileType
from app.services.file_storage_service import FileStorageService

storage = FileStorageService()

# Генерация пути для файла
file_path, filename = storage.generate_file_path(
    patient_id=123,
    file_type=MedicalFileType.CT_SCAN,
    original_filename="scan.dcm",
    study_date=date(2024, 1, 15)
)

# Использование в CRUD операциях
file_record = crud.file.create_with_version(
    db=db,
    obj_in=file_schema,
    file_content=file_content,
    user_id=current_user.id
)
```

## Миграция данных

Для миграции существующих файлов в новую систему:

1. Создать директории для всех пациентов
2. Переместить файлы согласно новой структуре
3. Обновить записи в базе данных
4. Проверить целостность данных

## Резервное копирование

Рекомендуемая стратегия:
- Регулярное резервное копирование базы данных SQLite
- Резервное копирование всей папки `storage/`
- Использование инкрементальных бэкапов для больших объемов
- Проверка целостности через SHA256 хеши

## Мониторинг

Ключевые метрики для отслеживания:
- Общий размер хранилища
- Количество файлов по типам
- Частота версионирования
- Время доступа к файлам
- Успешность загрузок